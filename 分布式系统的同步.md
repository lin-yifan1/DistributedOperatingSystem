# 分布式系统的同步
## 时钟同步
时钟同步的重要性，以 `make` 为例：`make` 的原理就是将源文件 `input.c` 与输出文件 `output.o` 的最后修改时间进行比较。如果 `output.o` 的最后修改时间时间先于 `input.c`，则源文件发生了更改，需要重新编译。在分布式系统中，如果 `input.c` 文件的时钟略快，可能会导致 `input.c` 发生了更改但 `make` 认为并没有发生更改。

### 逻辑时钟
逻辑时钟是一个相对于“物理时钟”的概念，由 Lamport 提出，指的是分布式系统中各个时钟无需与绝对时间进行同步，只需要保证事件的发生顺序不变即可。
- $a\rightarrow b$: $a$ 在 $b$ 之前发生，包含了两种情况：
	- 如果 $a$ 和 $b$ 是在同一进程中的两个事件，且 $a$ 发生在 $b$ 之前，则 $a\rightarrow b$ 为真；
	- 如果 $a$ 是一个进程发送某个消息的事件，$b$ 为另一个进程接收这个消息的事件，则 $a\rightarrow b$ 为真。
	- 如果 $a$ 和 $b$ 之间不交换信息，则称其为并发关系，谁先谁后不重要。

- 需要一种测量时间的方法 $C()$，使得当 $a\rightarrow b$ 时有 $C(a)<C(b)$；另外时间只能前进，不能倒退；只能加上一个值，不能减去一个值；同时任意时间 $a$ 和 $b$，必有 $C(a)\neq C(b)$.

![](./Figures/lamport.png)

可以看到，消息 C 是在时刻 60 从进程 3 离开，在时刻 56 到达进程 2，这是不可能的。D 同理。因此消息 C 到达进程 2 时，立刻把进程 2 的时钟调为 61。这就是 Lamport 算法。

### 时钟同步算法

TODO

#### Cristian 算法

TODO

#### Berkeley 算法

TODO

#### 平均值算法

TODO

## 互斥

多个进程通常需要使用临界区（critical region）来共享资源。当一个进程需要读写临界区里的数据时，它需要先进入临界区获得[互斥锁](https://en.wikipedia.org/wiki/Mutual_exclusion)（mutual exclusion, mutex）。

### 集中式算法

![](./Figures/mutex_centralized.png)

需要一个进程作为 coordinator

- 优点：没有进程会永远等待（no starvation）；
- 缺点：如果 coordinator 出错，整个系统就会崩溃。

### 分布式算法

- 由 Lamport 提出，Ricart 和 Agrawale 进行改进；
- 要求系统中所有事件的发生顺序必须无歧义；
- 当一个进程想进入临界区时，它需要创建一条包含 *想进入的临界区的名字、处理器id、当前时间* 的消息，然后将消息发送给所有的进程；
- 当进程接收到上述消息后，采取以下几种处理方案：
  - 如果接收者不在临界区也不想进入临界区，则向发送者发送 OK；
  - 如果接收者已经在临界区中，则不需要响应，而是将请求放入队列中；
  - 如果接收者不在临界区但是想进入临界区，那么需要将收到的消息与其他进程的时间戳进行对比，取小的那个。如果收到的消息时间戳最小，则发送 OK；如果接收者本身的时间戳最小，不回复并将请求放入队列中；

![](./Figures/mutex_distributed.png)

- 进程 0 发出时间戳为 8 的消息，进程 2 发出时间戳为 12 的消息（注意都给自己发了一份）；
- 进程 1 不想进入临界区，所以向进程 0 和 2 发送 OK；
- 进程 2 收到进程 0 的消息，对比时间戳后发现进程 0 的时间戳更小，所以向进程 0 发送 OK；
- 进程 0 收到进程 2 的消息，对比时间戳后发现自己更小，所以不回复消息，把进程 2 的请求放到队列中。当进程 0 结束临界区的使用后，会给进程 2 发送 OK；

### 令牌环算法

首先用软件构造进程的逻辑环：

![](./Figures/token_ring.png)

- 进程 0 首先获得 token；
- token 由进程 k 到进程 k+1 依次传递；
- 当进程 k+1 从进程 k 拿到 token 后，检查临界区是否为空。如果为空，则进入临界区，完成操作后将 token 传给下一个进程。一个 token 只能进入一个临界区；
- 如果进程 k+1 不想进入临界区，就直接把 token 往下传；
- 存在问题：令牌环丢失很难检测；

### 三种算法的比较

![](./Figures/mutex_three_alg.png)

- 集中式算法中，进出临界区需要三条信息：请求进入、同意进入、退出时释放；
- 分布式算法中，进入临界区需要 $n-1$ 条请求信息，并且需要 $n-1$ 条 OK 信息；
- 令牌环算法：如果所有的进程都想进入临界区，那么令牌每传递一次就会发生一次临界区的进出；如果没有进程想进入临界区，那么 message per entry/exit 就会趋于无穷大；如果一个进程想进入临界区，那么如果令牌刚好在手上，不需要等待就可以进入临界区；也有可能进程刚把令牌传出去，那么就需要 $n-1$ 条信息后才能再回到手上。

## 选举算法

分布式算法往往需要一个 coordinator（比如集中式互斥算法中的 coordinator），选举算法负责产生这个 coordinator。

### 欺负（Bully）算法

由 Garcia-Molina 提出，如果一个进程 P 发现 coordinator 不响应，它就发起选举：

- P 向所有号码比它大的进程发送 ELECTION 消息；
- 如果没有进程相应，则 P 成为 coordinator；
- 如果有进程相应，则响应的进程成为 coordinator；

因为号码最大的未崩溃进程总能选举获胜，所以称其为 Bully 算法。

![](./Figures/election_bully.png)

- 原来的 coordinator 进程 7 崩溃，进程 4 首先意识到了这一点，开始主持选举；
- 进程 4 向进程 5, 6, 7 发送选举消息；
- 进程 5 和 6 响应；
- 现在进程 5 和 6 分别主持选举；进程 5 向进程 6 和 7 发送选举消息；进程 6 向 进程 7 发送选举消息；
- 进程 6 获胜。

### 环算法

![](./Figures/election_ring.png)

- 如果进程发现 coordinator 不响应了，就把包含自身号码的消息沿着环往下发；
- 如果消息无法发给下一个进程，就发给下下个；
- 收到消息的进程把自己的号码放进消息，再往下发；
- 消息绕环一圈后，根据消息中的号码决定新的 coordinator（最大号码的那个进程）以及新的环成员。

## 原子事务

TODO

## 死锁